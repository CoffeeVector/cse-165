\documentclass[letterpaper, 12pt]{article}
\usepackage{xcolor, graphicx, savetrees}
\usepackage{amsmath, amsthm, amssymb, physics, mathtools, siunitx, cancel}
\usepackage{multicol, subcaption}
\usepackage{url, listings}
\title{CSE 165 Final Project Report}
\author{Hunter McClellan \and Higinio Ramirez \and Kevin Zheng}
\begin{document}
\maketitle
\section{Project Description}
Our project is recreating the famous Tetris game in 3D.
Rather than clearing ``lines'', the player is expected to clear layers.
The pieces will be reminiscent of the original pieces, since most of them can be quite naturally generalized.
\section{Member Contribution}
The contribution can be roughly be separated by file as as
\begin{multicols}{3}

\begin{itemize}
    \item Hunter McClellan
        \begin{enumerate}
            \item \path{mainwindow.h}
            \item \path{mainwindow.cpp}
            \item \path{Ground.h}
        \end{enumerate}
    \columnbreak
    \item Higinio Ramirez
        \begin{enumerate}
            \item \path{Points.cpp}
            \item \path{Randomizer.cpp}
        \end{enumerate}
    \columnbreak
    \item Kevin Zheng
        \begin{enumerate}
            \item \path{Tetris.h}
            \item \path{Tetris_Graphics.h}
        \end{enumerate}
\end{itemize}
\end{multicols}
\section{Implementation}
\subsection{Tetris.h}
Handles all game logic
\begin{itemize}
    \item \verb|GameState| enum: has only two members, \verb|PLAYING| and \verb|LOSE|. Sorry, you can't win this game!
    \item \verb|Moves| enum: has eight members, \verb|DOWN|, \verb|LEFT|, \verb|RIGHT|, \verb|FORWARD|, \verb|BACK|, \verb|PITCH|, \verb|ROLL|, \verb|YAW|.
    \item \verb|Block| struct: has three integers for red, green, blue which range from 0 to 255.
        The \verb|Block| struct also has one bool that indicates whether or not the block is falling.
        Falling in this context is synonymous with ``in play.''
        Note that the location of the \verb|Block| is not handled by the \verb|Block|, it is handled by the \verb|Tetris| class.
    \item \verb|Tetris| class: has a quadruple \verb|Block| pointer denoted by \verb|state|.
        This can be best understood as three dimensional array of \verb|Block| pointers.
        This number of pointers is necessary, since want to allow parts of the array to be \verb|NULL|.
        There are three integers for width, length, and height of the playing field.
        \begin{itemize}
            \item \verb|ind2sub(int ind, int &x, int &y, int &z)|. Short for ``index to subscript''.
                This method accepts a number from 0 to \verb|w*l*h-1|, and ``returns by reference'' the corresponding \verb|x|, \verb|y|, \verb|z| coordinates.
                This is used in the cases where we want to loop through every \verb|Block| in \verb|state|, but would rather not use a triple for loop.
                Instead, we can make one loop, and use \verb|ind2sub|.
            \item \verb|int sub2ind(int x, int y, int z)|: This is the reverse operation of \verb|ind2sub|.
            \item \verb|GameState control(Moves moves)| accepts a member of the \verb|Move| enum and modifies the \verb|state| accordingly.
                If the control made by the player results in a loss or not will be reflected in the \verb|GameState| return.
                The body of this method is simply a \verb|switch| statement calling either \verb|translate_piece| or \verb|rotate_piece|.
            \item \verb|GameState translate_piece(Moves move)| handles the translation of pieces. This is called by \verb|advance| as well as \verb|control|
            \item \verb|void rotate_piece(Moves move)| rotates the piece.
                Note that the return is \verb|void| since a rotation can never cause a loss.
            \item \verb|void handle_layer_clear()| Checks for cleared layers, and remove them.
            \item \verb|GameState spawn_piece()| attempts to spawn in a random piece at the top of the playing field.
                Failure to due so is the definition of a loss, and such will be returned.
            \item \verb|GameState advance()| is an alias for \verb|translate_piece(DOWN)|, as well as a \verb|handle_layer_clear()|.
        \end{itemize}
\end{itemize}
\subsection{Tetris\_Graphics.h}
Has a constructor which accepts a \verb|Tetris*|.
Has a \verb|void draw()| method which draws the Blocks in \verb|Tetris|.
\subsection{mainwindow.h/mainwindow.cpp}
Handles keyboard input, mouse input, and graphics.
Has class \verb|MainWindow| which extends \verb|QOpenGLWindow|.
Implementes the generic methods of \verb|QOpenGLWindow| like in the labs.
Adds a \verb|SLOT| for the method \verb|GameAdvance()| which is an alias for \verb|Tetris.advance()| which is bound to a \verb|QTimer| for once a second.
\begin{itemize}
    \item \verb|void paintGL()|.
        Starts by clearing the \verb|GL_COLOR_BUFFER_BIT| and the \verb|GL_DEPTH_BUFFER_BIT| and calls \verb|glLoadIdentity|.
        Then we do a \verb|gl_Translate(0.0, 0.0, -35.0)|, which elevates the camera by \verb|35.0|, this is so the player has a somewhat downward facing view of the playing field.
        Then we call \verb|glRotatef| for each direction.
        Then, we can call \verb|Tetris_Graphics.draw()| and \verb|Ground.draw()|, to draw the ground and the game pieces.
        Afterwards, the controls are handled by checking for if the \verb|W,A,S,D|, $\uparrow$, $\downarrow$, $\leftarrow$, $\rightarrow$ keys have been pressed, and then make the corresponding call to \verb|Tetris.control()|.
    \item \verb|void keyPressEvent(QKeyEvent *event)| checks which of the \verb|W,A,S,D|, $\uparrow$, $\downarrow$, $\leftarrow$, $\rightarrow$ keys have been pressed, and then sets the corresponding member boolean to be true.
        The escape key calls \verb|qApp->exit()|to exit the game.
        Note that these member booleans are also set to false after \verb|paintGL| as to prevent the game from doing the move twice before release.
    \item \verb|void keyReleaseEvent(QKeyEvent *event)| does the opposite of \verb|keyPressEvent|.
    \item \verb|void mouseMoveEvent(QMouseEvent *event)| modifies the \verb|cam_x_r, cam_y_r, cam_z_r| according to the position of the mouse.
        This method also resets the position of the mouse to the center.
        This is to prevent the mouse to leave the window as the player moves the mouse for a different perspective.
        To regain normal use of the cursor, exit the game.
\end{itemize}
\subsection{Points.cpp}
\subsection{Randomizer.cpp}
\section{Lessons/Conclusions}
\subsection{Depth Bit}
The depth bit, or depth buffer, is a noter
Not all systems will allocate space for the depth bit.

\end{document}
